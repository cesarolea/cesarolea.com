<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Writing AWS lambdas with ClojureScript - César Olea</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Writing AWS lambdas with ClojureScript">
<meta itemprop="description" content="Rationale When I created the anvil template, I did it to learn how to create a ClojureScript project from scratch, tailoring it to my exact needs for frontend development. Those needs can be summarized in three key points:
 Code reloading. A browser connected REPL. Connectivity to the REPL from Emacs/CIDER.  At the time I was doing a lot of frontend ClojureScript development in the form of animations with Quil (see my raycaster demo and the old-school fire effect) and the pattern for the template emerged from those projects, though it can also be used for more &ldquo;serious&rdquo; Web frontend development.">
<meta itemprop="datePublished" content="2021-01-12T20:01:00-07:00" />
<meta itemprop="dateModified" content="2021-01-12T20:01:00-07:00" />
<meta itemprop="wordCount" content="2659">



<meta itemprop="keywords" content="" />
<meta property="og:title" content="Writing AWS lambdas with ClojureScript" />
<meta property="og:description" content="Rationale When I created the anvil template, I did it to learn how to create a ClojureScript project from scratch, tailoring it to my exact needs for frontend development. Those needs can be summarized in three key points:
 Code reloading. A browser connected REPL. Connectivity to the REPL from Emacs/CIDER.  At the time I was doing a lot of frontend ClojureScript development in the form of animations with Quil (see my raycaster demo and the old-school fire effect) and the pattern for the template emerged from those projects, though it can also be used for more &ldquo;serious&rdquo; Web frontend development." />
<meta property="og:type" content="article" />
<meta property="og:url" content="//www.cesarolea.com/posts/aws-lambdas-with-clojurescript/" />
<meta property="article:published_time" content="2021-01-12T20:01:00-07:00" />
<meta property="article:modified_time" content="2021-01-12T20:01:00-07:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Writing AWS lambdas with ClojureScript"/>
<meta name="twitter:description" content="Rationale When I created the anvil template, I did it to learn how to create a ClojureScript project from scratch, tailoring it to my exact needs for frontend development. Those needs can be summarized in three key points:
 Code reloading. A browser connected REPL. Connectivity to the REPL from Emacs/CIDER.  At the time I was doing a lot of frontend ClojureScript development in the form of animations with Quil (see my raycaster demo and the old-school fire effect) and the pattern for the template emerged from those projects, though it can also be used for more &ldquo;serious&rdquo; Web frontend development."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
	<h1 class="site-title"><a href="/">César Olea</a></h1>
	<div class="site-description"><p>Software Developer | CTO of <a href="https://loanpro.io">LoanPro</a></p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/cesarolea" title="Github"><i data-feather="github"></i></a></li><li><a href="https://linkedin.com/in/cesarolea" title="Linkedin"><i data-feather="linkedin"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav><span class="scheme-toggle"><a href="#" id="scheme-toggle"></a></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts/index.html">Blog</a>
			</li>
			
			<li>
				<a href="/about/index.html">About</a>
			</li>
			
			<li>
				<a href="/rockofonia/index.html">Rockofonia</a>
			</li>
			
			<li>
				<a href="/resume.pdf">Resume</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">12</span>
							<span class="rest">Jan 2021</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Writing AWS lambdas with ClojureScript</h1>
				</div>
			</div>
					
			<div class="markdown">
				<h2 id="rationale">Rationale</h2>
<p>When I created <a href="https://github.com/cesarolea/anvil-lein-template">the anvil template</a>, I did it to learn how to create a
ClojureScript project from scratch, tailoring it to my exact needs for
<strong>frontend development</strong>. Those needs can be summarized in three key
points:</p>
<ol>
<li>Code reloading.</li>
<li>A browser connected REPL.</li>
<li>Connectivity to the REPL from Emacs/CIDER.</li>
</ol>
<p>At the time I was doing a lot of frontend ClojureScript development in
the form of animations with <a href="http://quil.info">Quil</a> (see my
<a href="https://blog.cesarolea.com/posts/raycasting-demo/index.html">raycaster
demo</a> and the <a href="https://blog.cesarolea.com/posts/efecto-de-fuego-con-clojurescript/index.html">old-school fire effect</a>) and the pattern for the
template emerged from those projects, though it can also be used for
more &ldquo;serious&rdquo; Web frontend development.</p>
<p>Nowadays I&rsquo;m not doing so much frontend development, but there&rsquo;s a
specific need where ClojureScript would really shine: backend
development with AWS lambda.</p>
<h3 id="why-clojurescript-and-not-clojure">Why ClojureScript and not Clojure</h3>
<p>I do maintain some JVM (Clojure) based lambdas at work. The
development experience is fantastic and deploying couldn&rsquo;t be
easier: create an uberjar, and ship it to AWS. Couple this with the
fact that the AWS SDK for Java is one if not the best SDK out
there, and the overall experience is hard to beat.</p>
<p>The problem is lambda cold starts. AWS lambda will create an
execution environment for your code, download the package, start
the JVM and execute it. This whole process is in the order of
seconds, which is nothing short of amazing, but can have big
implications if some of your requests start taking 5 or 10 seconds
instead of milliseconds. In addition, lambdas are billed by the
millisecond and you pay for the cold start time, so it makes sense
from the pricing point of view to reduce cold start time.</p>
<h2 id="goals">Goals</h2>
<p>My goals for creating AWS lambdas in ClojureScript are:</p>
<ol>
<li>Compile ClojureScript to run in nodejs locally.</li>
<li>Use npm dependencies.</li>
<li>Connect the REPL to Emacs/CIDER.</li>
<li>Deploy and run as AWS lambda.</li>
</ol>
<h2 id="step-1-compile-clojurescript-to-run-in-nodejs">Step 1: Compile ClojureScript to run in nodejs</h2>
<p>Start with a default Clojure (that&rsquo;s right, Clojure and not
ClojureScript) project.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">lein new app hello-lambda-cljs
</code></pre></div><p>It generates a project with the following structure:</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">.
├── CHANGELOG.md
├── LICENSE
├── README.md
├── doc
│   └── intro.md
├── project.clj
├── resources
├── src
│   └── hello_lambda_cljs
│       └── core.clj
└── <span style="color:#a2f">test</span>
    └── hello_lambda_cljs
        └── core_test.clj
</code></pre></div><p>We&rsquo;ll remove what&rsquo;s not needed:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#a2f">cd</span> hello-lambda-cljs
rm -r <span style="color:#a2f">test</span> resources doc README.md LICENSE CHANGELOG.md src/hello_lambda_cljs/core.clj
touch src/hello_lambda_cljs/core.cljs
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">.
├── project.clj
└── src
    └── hello_lambda_cljs
        └── core.cljs
</code></pre></div><p>We&rsquo;ll use the trusty old <code>cljsbuild</code> leiningen plugin. I like this
plugin as it&rsquo;s basically a no-frills gateway into the ClojureScript
compiler.</p>
<p>Here&rsquo;s how we set our <code>project.clj</code> to compile our ClojureScript code
for node execution:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">defproject </span><span style="color:#b8860b">hello-lambda-cljs</span> <span style="color:#b44">&#34;1.0.0&#34;</span>
  <span style="color:#b8860b">:dependencies</span> [[<span style="color:#b8860b">org.clojure/clojure</span> <span style="color:#b44">&#34;1.10.1&#34;</span>]
                 [<span style="color:#b8860b">org.clojure/clojurescript</span> <span style="color:#b44">&#34;1.10.758&#34;</span>]]
  <span style="color:#b8860b">:plugins</span> [[<span style="color:#b8860b">lein-cljsbuild</span> <span style="color:#b44">&#34;1.1.8&#34;</span>]]
  <span style="color:#b8860b">:cljsbuild</span>
  {<span style="color:#b8860b">:builds</span> [{<span style="color:#b8860b">:source-paths</span> [<span style="color:#b44">&#34;src&#34;</span>]
             <span style="color:#b8860b">:compiler</span> {<span style="color:#b8860b">:output-to</span> <span style="color:#b44">&#34;hello_lambda_cljs.js&#34;</span>
                        <span style="color:#b8860b">:main</span> <span style="color:#b8860b">hello-lambda-cljs.core</span>
                        <span style="color:#b8860b">:target</span> <span style="color:#b8860b">:nodejs</span>
                        <span style="color:#b8860b">:optimizations</span> <span style="color:#b8860b">:simple</span>}}]})
</code></pre></div><p>The most important part of this <code>project.clj</code> is the <code>:compiler</code>
map. This map is passed to the ClojureScript compiler directly, so
it&rsquo;s worth <a href="https://clojurescript.org/reference/compiler-options">getting familiar with all the options at your disposal</a>.</p>
<p>Almost done. Before compiling we need something to compile. Edit
<code>src/hello_lambda_cljs/core.cljs</code> with the following code:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">ns </span><span style="color:#b8860b">hello-lambda-cljs.core</span>)

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">say-hello</span> []
  <span style="color:#b44">&#34;Hello World!&#34;</span>)

(<span style="color:#a2f">println </span>(<span style="color:#00a000">say-hello</span>))
</code></pre></div><p>The purpose of this very simple ClojureScript program is to verify
that we can compile our project and run the compiled output with
nodejs.</p>
<p>To build: <code>lein cljsbuild once</code>. There should be a
<code>hello_lambda_cljs.js</code> file in the root of the project. This program
is runnable locally by nodejs but it can&rsquo;t be executed by AWS lambda
yet. We&rsquo;ll get to that in <a href="#step-4-deploy-and-run-as-aws-lambda">Step 4</a>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">node hello_lambda_cljs.js
Hello guys!
</code></pre></div><h2 id="step-2-use-npm-dependencies">Step 2: Use npm dependencies</h2>
<p>In writing backend JavaScript (ClojureScript in our case) eventually
you&rsquo;ll need to use a JavaScript (not ClojureScript) library, and this
means interacting with npm. This is especially true for AWS lambdas as
more often than not you&rsquo;ll use the AWS SDK for JavaScript to consume
other AWS services from your lambda function.</p>
<p>ClojureScript makes it very easy to use npm libraries. Simply declare
them as npm dependencies in your ClojureScript build definition. In
<code>project.clj</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">defproject </span><span style="color:#b8860b">hello-lambda-cljs</span> <span style="color:#b44">&#34;1.0.0&#34;</span>
  <span style="color:#b8860b">:dependencies</span> [[<span style="color:#b8860b">org.clojure/clojure</span> <span style="color:#b44">&#34;1.10.1&#34;</span>]
                 [<span style="color:#b8860b">org.clojure/clojurescript</span> <span style="color:#b44">&#34;1.10.758&#34;</span>]]
  <span style="color:#b8860b">:plugins</span> [[<span style="color:#b8860b">lein-cljsbuild</span> <span style="color:#b44">&#34;1.1.8&#34;</span>]]
  <span style="color:#b8860b">:cljsbuild</span>
  {<span style="color:#b8860b">:builds</span> [{<span style="color:#b8860b">:source-paths</span> [<span style="color:#b44">&#34;src&#34;</span>]
             <span style="color:#b8860b">:compiler</span> {<span style="color:#b8860b">:output-to</span> <span style="color:#b44">&#34;hello_lambda_cljs.js&#34;</span>
                        <span style="color:#b8860b">:main</span> <span style="color:#b8860b">hello-lambda-cljs.core</span>
                        <span style="color:#b8860b">:target</span> <span style="color:#b8860b">:nodejs</span>
                        <span style="color:#b8860b">:optimizations</span> <span style="color:#b8860b">:simple</span>
                        <span style="color:#b8860b">:npm-deps</span> {<span style="color:#b8860b">:luxon</span> <span style="color:#b44">&#34;1.25.0&#34;</span>}
                        <span style="color:#b8860b">:install-deps</span> <span style="color:#b8860b">true</span>}}]})
</code></pre></div><p>Note how two keys were added: <code>:npm-deps</code> and
<code>:install-deps</code>. Compiling this code now will fetch the <code>luxon</code>
library (used as an example) from npm and allow our code to require
it, just as any other ClojureScript library:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">ns </span><span style="color:#b8860b">hello-lambda-cljs.core</span>
  (<span style="color:#b8860b">:require</span> [<span style="color:#b8860b">luxon</span> <span style="color:#b8860b">:refer</span> [<span style="color:#b8860b">DateTime</span>]]))

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">today-as-string</span> []
  (<span style="color:#a2f">-&gt; </span><span style="color:#b8860b">DateTime</span> <span style="color:#b8860b">.local</span> <span style="color:#b8860b">.toString</span>))

(<span style="color:#a2f">println </span>(<span style="color:#00a000">today-as-string</span>))
</code></pre></div><p>Upon compilation, the ClojureScript compiler will download the
dependencies from npm and compile them in such a way that they can be
required by your compiled program. A <code>node_modules</code> directory will be
placed in your project root along with familiar npm artifacts
<code>package.json</code> and <code>package-lock.json</code>.</p>
<p>Note that if you don&rsquo;t <code>:require</code> any npm libraries in ClojureScript
code, then the dependencies won&rsquo;t be fetched from npm even if they are
declared as dependencies to the ClojureScript compiler.</p>
<p>Running the newly compiled file:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">node hello_lambda_cljs.js
2021-01-11T10:25:06.099-07:00
</code></pre></div><p>What about more complex libraries? It&rsquo;s the same. First declare them
in <code>project.clj</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">defproject </span><span style="color:#b8860b">hello-lambda-cljs</span> <span style="color:#b44">&#34;1.0.0&#34;</span>
  <span style="color:#b8860b">:dependencies</span> [[<span style="color:#b8860b">org.clojure/clojure</span> <span style="color:#b44">&#34;1.10.1&#34;</span>]
                 [<span style="color:#b8860b">org.clojure/clojurescript</span> <span style="color:#b44">&#34;1.10.758&#34;</span>]]
  <span style="color:#b8860b">:plugins</span> [[<span style="color:#b8860b">lein-cljsbuild</span> <span style="color:#b44">&#34;1.1.8&#34;</span>]]
  <span style="color:#b8860b">:cljsbuild</span>
  {<span style="color:#b8860b">:builds</span> [{<span style="color:#b8860b">:source-paths</span> [<span style="color:#b44">&#34;src&#34;</span>]
             <span style="color:#b8860b">:compiler</span> {<span style="color:#b8860b">:output-to</span> <span style="color:#b44">&#34;hello_lambda_cljs.js&#34;</span>
                        <span style="color:#b8860b">:main</span> <span style="color:#b8860b">hello-lambda-cljs.core</span>
                        <span style="color:#b8860b">:target</span> <span style="color:#b8860b">:nodejs</span>
                        <span style="color:#b8860b">:optimizations</span> <span style="color:#b8860b">:simple</span>
                        <span style="color:#b8860b">:npm-deps</span> {<span style="color:#b8860b">:luxon</span> <span style="color:#b44">&#34;1.25.0&#34;</span>
                                   <span style="color:#b8860b">:aws-sdk</span> <span style="color:#b44">&#34;2.824.0&#34;</span>}
                        <span style="color:#b8860b">:install-deps</span> <span style="color:#b8860b">true</span>}}]})
</code></pre></div><p>And require them in code as you usually would with Clojure(Script)
libraries.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">ns </span><span style="color:#b8860b">hello-lambda-cljs.core</span>
  (<span style="color:#b8860b">:require</span> [<span style="color:#b8860b">luxon</span> <span style="color:#b8860b">:refer</span> [<span style="color:#b8860b">DateTime</span>]]
            [<span style="color:#b8860b">aws-sdk</span> <span style="color:#b8860b">:as</span> <span style="color:#b8860b">aws</span>]
            [<span style="color:#b8860b">cljs.pprint</span> <span style="color:#b8860b">:refer</span> [<span style="color:#b8860b">pprint</span>]]))

<span style="color:#080;font-style:italic">;; set AWS credentials from profile</span>
(<span style="color:#00a000">set!</span> (<span style="color:#00a000">.-credentials</span> <span style="color:#b8860b">aws/config</span>)
      (<span style="color:#00a000">aws/SharedIniFileCredentials.</span> <span style="color:#666">#</span><span style="color:#b8860b">js</span> {<span style="color:#b8860b">:profile</span> <span style="color:#b44">&#34;test&#34;</span>}))
(<span style="color:#a2f;font-weight:bold">def </span><span style="color:#b8860b">s3</span> (<span style="color:#00a000">aws/S3.</span>))

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">list-buckets</span> []
  (<span style="color:#a2f">println </span><span style="color:#b44">&#34;Requesting your buckets...&#34;</span>)
  (<span style="color:#00a000">.listBuckets</span> <span style="color:#b8860b">s3</span> (<span style="color:#a2f;font-weight:bold">fn </span>[<span style="color:#b8860b">err</span> <span style="color:#b8860b">data</span>]
                     (<span style="color:#a2f;font-weight:bold">if </span><span style="color:#b8860b">err</span>
                       (<span style="color:#a2f">println </span><span style="color:#b44">&#34;ERROR: &#34;</span> <span style="color:#b8860b">err</span>)
                       (<span style="color:#00a000">pprint</span> (<span style="color:#00a000">js-&gt;clj</span> <span style="color:#b8860b">data</span>))))))

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">today-as-string</span> []
  (<span style="color:#a2f">-&gt; </span><span style="color:#b8860b">DateTime</span> <span style="color:#b8860b">.local</span> <span style="color:#b8860b">.toString</span>))

(<span style="color:#a2f">println </span>(<span style="color:#00a000">today-as-string</span>))

(<span style="color:#00a000">list-buckets</span>)
</code></pre></div><p>A few pointers before running the code. First, a <code>test</code> AWS CLI
profile needs to exists in your local computer. Hardcoded here for
illustrative purposes only, but will have to be replaced with a
flexible solution before deploying as AWS lambda.</p>
<p>Second, your <code>test</code> profile needs to have permissions to read your S3
buckets. An IAM tutorial is out of the scope of this article, so it is
left as an exercise to the reader.</p>
<p>Third, we are still in &ldquo;callback hell&rdquo;. This is in part because we are
using the JavaScript AWS SDK library directly. This is something that
can be fixed by using <code>core.async</code>. See <a href="#extras">Extras</a>.</p>
<p>Compile and run locally as before, you should get a listing of all
your S3 buckets in a Clojure map:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">{</span><span style="color:#b44">&#34;Buckets&#34;</span>
 <span style="color:#666">[{</span><span style="color:#b44">&#34;Name&#34;</span>
   <span style="color:#b44">&#34;some-bucket-1&#34;</span>,
   <span style="color:#b44">&#34;CreationDate&#34;</span> <span style="color:#080;font-style:italic">#inst &#34;2020-08-13T19:22:22.000-00:00&#34;}</span>
  <span style="color:#666">{</span><span style="color:#b44">&#34;Name&#34;</span> <span style="color:#b44">&#34;some-other-bucket&#34;</span>,
   <span style="color:#b44">&#34;CreationDate&#34;</span> <span style="color:#080;font-style:italic">#inst &#34;2020-08-21T17:12:16.000-00:00&#34;}</span>
  <span style="color:#666">{</span><span style="color:#b44">&#34;Name&#34;</span>
   <span style="color:#b44">&#34;yet-another-bucket&#34;</span>,
   <span style="color:#b44">&#34;CreationDate&#34;</span> <span style="color:#080;font-style:italic">#inst &#34;2020-10-18T16:18:52.000-00:00&#34;}</span>
  <span style="color:#666">{</span><span style="color:#b44">&#34;Name&#34;</span> <span style="color:#b44">&#34;and-some-more-buckets&#34;</span>,
   <span style="color:#b44">&#34;CreationDate&#34;</span> <span style="color:#080;font-style:italic">#inst &#34;2020-07-07T15:09:09.000-00:00&#34;}],</span>
 <span style="color:#b44">&#34;Owner&#34;</span>
 <span style="color:#666">{</span><span style="color:#b44">&#34;DisplayName&#34;</span> <span style="color:#b44">&#34;your-aws-account&#34;</span>,
  <span style="color:#b44">&#34;ID&#34;</span>
  <span style="color:#b44">&#34;some-random-id&#34;</span><span style="color:#666">}}</span>
</code></pre></div><h2 id="step-3-the-repl">Step 3: The REPL</h2>
<p>While the main objective is to run our ClojureScript code (transpiled
to JavaScript code) in AWS as a lambda function, equally important is
the development experience. Without the REPL this experience would be
significantly hampered.</p>
<p>There are multiple ways to achieve it. CIDER in Emacs supports a
nodejs REPL. The process is very simple, you <code>M-x cider-jack-in-cljs</code>,
select node as REPL and it starts node as a subprocess. But I prefer
running the server in a separate terminal, and let CIDER connect to
it.</p>
<p>For the REPL we&rsquo;ll use <a href="https://github.com/thheller/shadow-cljs">shadow-cljs</a>. Shadow-cljs is much more than just
a REPL, but we won&rsquo;t be using any of its other capabilities here.</p>
<p>To install shadow-cljs, in your project root <code>npm install -D shadow-cljs</code>. It will add shadow-cljs as a development
dependency. Next we need to add a configuration file for shadow-cljs
<code>shadow-cljs.edn</code> with content:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">{<span style="color:#b8860b">:dependencies</span> [[<span style="color:#b8860b">cider/cider-nrepl</span> <span style="color:#b44">&#34;0.25.6&#34;</span>]]}
</code></pre></div><p>Your project tree should look like this:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">.
├── project.clj
├── shadow-cljs.clj
└── src
    └── hello_lambda_cljs
        └── core.cljs
</code></pre></div><p>Running the REPL is as easy as executing <code>npx shadow-cljs node-repl</code>. After a while it will respond with:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">shadow-cljs - server version: 2.11.13 running at http://localhost:9630
shadow-cljs - nREPL server started on port <span style="color:#666">39049</span>
cljs.user<span style="color:#666">=</span>&gt; shadow-cljs - <span style="color:#080;font-style:italic">#4 ready!</span>
</code></pre></div><p>To connect to this REPL from Emacs/CIDER <code>M-x cider-connect-cljs</code> and
follow the prompts. It will ask for:</p>
<ul>
<li>Host: <code>localhost</code></li>
<li>Port: In this case <code>39049</code></li>
<li>Type of REPL: <code>shadow</code></li>
<li>Shadow build: <code>node-repl</code></li>
</ul>
<p>It should connect and be able to use it just as you would with a
Clojure REPL.</p>
<figure>
    <img src="/ox-hugo/cider-clojurescript-repl.png"/> 
</figure>

<h2 id="step-4-deploy-and-run-as-aws-lambda">Step 4: Deploy and run as AWS lambda</h2>
<p>Before deploying as AWS lambda there&rsquo;s two things we need to fix:</p>
<ol>
<li>The profile credentials need to be set only if running
locally. When running as lambda it should pick its credentials from
the role assigned to it.</li>
<li>There&rsquo;s no AWS lambda entry point.</li>
</ol>
<p>We can use the presence of the <code>AWS_PROFILE</code> environment variable as a
flag to either set the credentials ourselves, or let the SDK take the
lambda role.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">ns </span><span style="color:#b8860b">hello-lambda-cljs.core</span>
  (<span style="color:#b8860b">:require</span> [<span style="color:#b8860b">aws-sdk</span> <span style="color:#b8860b">:as</span> <span style="color:#b8860b">aws</span>]
            [<span style="color:#b8860b">cljs.pprint</span> <span style="color:#b8860b">:refer</span> [<span style="color:#b8860b">pprint</span>]]))

<span style="color:#080;font-style:italic">;; set AWS credentials from profile</span>
(<span style="color:#a2f">when </span>(<span style="color:#a2f">-&gt; </span><span style="color:#b8860b">js/process</span> <span style="color:#b8860b">.-env</span> <span style="color:#b8860b">.-AWS_PROFILE</span>)
  (<span style="color:#00a000">set!</span> (<span style="color:#00a000">.-credentials</span> <span style="color:#b8860b">aws/config</span>)
        (<span style="color:#00a000">aws/SharedIniFileCredentials.</span>
         <span style="color:#666">#</span><span style="color:#b8860b">js</span> {<span style="color:#b8860b">:profile</span> (<span style="color:#a2f">-&gt; </span><span style="color:#b8860b">js/process</span> <span style="color:#b8860b">.-env</span> <span style="color:#b8860b">.-AWS_PROFILE</span>)})))
(<span style="color:#a2f;font-weight:bold">def </span><span style="color:#b8860b">s3</span> (<span style="color:#00a000">aws/S3.</span>))

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">list-buckets</span> []
  (<span style="color:#a2f">println </span><span style="color:#b44">&#34;Requesting your buckets...&#34;</span>)
  (<span style="color:#00a000">.listBuckets</span> <span style="color:#b8860b">s3</span> (<span style="color:#a2f;font-weight:bold">fn </span>[<span style="color:#b8860b">err</span> <span style="color:#b8860b">data</span>]
                     (<span style="color:#a2f;font-weight:bold">if </span><span style="color:#b8860b">err</span>
                       (<span style="color:#a2f">println </span><span style="color:#b44">&#34;ERROR: &#34;</span> <span style="color:#b8860b">err</span>)
                       (<span style="color:#00a000">pprint</span> (<span style="color:#00a000">js-&gt;clj</span> <span style="color:#b8860b">data</span>))))))

(<span style="color:#00a000">list-buckets</span>)
</code></pre></div><p>With the code above, if the environment variable <code>AWS_PROFILE</code> is not
set, then the SDK will follow it&rsquo;s own authentication chain. When
running locally we will set the <code>AWS_PROFILE</code> to our IAM profile and
when running in a lambda we will simply not set it, allowing the role
assigned to the lambda to take over. This fixes issue #1.</p>
<p>Issue #2 requires us to specify the lambda entry point, its
<strong>handler</strong>. The handler is the function that the AWS lambda runtime
will execute and needs to have a specific signature.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">ns </span><span style="color:#b8860b">hello-lambda-cljs.core</span>
  (<span style="color:#b8860b">:require</span> [<span style="color:#b8860b">aws-sdk</span> <span style="color:#b8860b">:as</span> <span style="color:#b8860b">aws</span>]
            [<span style="color:#b8860b">cljs.pprint</span> <span style="color:#b8860b">:refer</span> [<span style="color:#b8860b">pprint</span>]]))

<span style="color:#080;font-style:italic">;; set AWS credentials from profile</span>
(<span style="color:#a2f">when </span>(<span style="color:#a2f">-&gt; </span><span style="color:#b8860b">js/process</span> <span style="color:#b8860b">.-env</span> <span style="color:#b8860b">.-AWS_PROFILE</span>)
  (<span style="color:#00a000">set!</span> (<span style="color:#00a000">.-credentials</span> <span style="color:#b8860b">aws/config</span>)
        (<span style="color:#00a000">aws/SharedIniFileCredentials.</span>
         <span style="color:#666">#</span><span style="color:#b8860b">js</span> {<span style="color:#b8860b">:profile</span> (<span style="color:#a2f">-&gt; </span><span style="color:#b8860b">js/process</span> <span style="color:#b8860b">.-env</span> <span style="color:#b8860b">.-AWS_PROFILE</span>)})))
(<span style="color:#a2f;font-weight:bold">def </span><span style="color:#b8860b">s3</span> (<span style="color:#00a000">aws/S3.</span>))

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">list-buckets</span> []
  (<span style="color:#a2f">println </span><span style="color:#b44">&#34;Requesting your buckets...&#34;</span>)
  (<span style="color:#00a000">.listBuckets</span> <span style="color:#b8860b">s3</span> (<span style="color:#a2f;font-weight:bold">fn </span>[<span style="color:#b8860b">err</span> <span style="color:#b8860b">data</span>]
                     (<span style="color:#a2f;font-weight:bold">if </span><span style="color:#b8860b">err</span>
                       (<span style="color:#a2f">println </span><span style="color:#b44">&#34;ERROR: &#34;</span> <span style="color:#b8860b">err</span>)
                       (<span style="color:#00a000">pprint</span> (<span style="color:#00a000">js-&gt;clj</span> <span style="color:#b8860b">data</span>))))))

(<span style="color:#00a000">list-buckets</span>)

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">handler</span>
  <span style="color:#b44">&#34;Lambda main entry point&#34;</span>
  [<span style="color:#b8860b">event</span> <span style="color:#b8860b">context</span> <span style="color:#b8860b">callback</span>]
  (<span style="color:#00a000">do</span>
    (<span style="color:#00a000">pprint</span> <span style="color:#b8860b">event</span>)
    (<span style="color:#00a000">callback</span> <span style="color:#b8860b">nil</span>
              (<span style="color:#00a000">clj-&gt;js</span> {<span style="color:#b8860b">:status</span> <span style="color:#666">200</span>
                        <span style="color:#b8860b">:body</span> <span style="color:#b44">&#34;Hello from AWS Lambda in ClojureScript!&#34;</span>
                        <span style="color:#b8860b">:headers</span> {}}))))

(<span style="color:#00a000">set!</span> (<span style="color:#00a000">.-exports</span> <span style="color:#b8860b">js/module</span>) <span style="color:#666">#</span><span style="color:#b8860b">js</span> {<span style="color:#b8860b">:handler</span> <span style="color:#b8860b">handler</span>})
</code></pre></div><p>The relevant code is at the bottom. First we create a new function
<code>handler</code> with <a href="https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html">the 3 arg signature specified by AWS lambda</a>. Then we
set this handler as a ES6 module export as required by the lambda
runtime. This fixes issue #2.</p>
<p>Compile, package and deploy to AWS. Note how permissions on the
JavaScript file are set to execute for all. If this is not set, the
lambda runtime won&rsquo;t be able to execute our handler and fail with a
generic &ldquo;EACCESS&rdquo; error.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">lein cljsbuild once
chmod <span style="color:#666">755</span> hello_lambda_cljs.js
zip -r hello-lambda-cljs.zip hello_lambda_cljs.js node_modules
aws lambda update-function-code --function-name hello-lambda-cljs --zip-file fileb://hello-lambda-cljs.zip --profile <span style="color:#a2f">test</span>
</code></pre></div><p>The last step above assumes a lambda already exists with function name
<code>hello-lambda-cljs</code>. The most critical part of the lambda
configuration is <strong>the handler</strong>. In our case set the handler to <code>hello_lambda_cljs.handler</code>.</p>
<figure>
    <img src="/ox-hugo/lambda-execute.png"/> 
</figure>

<p>Note in the screenshot above how there&rsquo;s an Access Denied error. This
is because the role my lambda has doesn&rsquo;t have access to read all
buckets. This is easily solvable by adding the required IAM permission
to the lambda role.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
    <span style="color:#b44">&#34;Sid&#34;</span><span style="color:#666">:</span> <span style="color:#b44">&#34;VisualEditor2&#34;</span>,
    <span style="color:#b44">&#34;Effect&#34;</span><span style="color:#666">:</span> <span style="color:#b44">&#34;Allow&#34;</span>,
    <span style="color:#b44">&#34;Action&#34;</span><span style="color:#666">:</span> <span style="color:#b44">&#34;s3:ListAllMyBuckets&#34;</span>,
    <span style="color:#b44">&#34;Resource&#34;</span><span style="color:#666">:</span> <span style="color:#b44">&#34;*&#34;</span>
}
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Writing AWS lambdas in ClojureScript is possible by transpiling
ClojureScript to JavaScript, and desirable due to lower cold start
times compared to Clojure and the JVM.</p>
<p>The ClojureScript tooling has matured enough to use this approach in
production, beyond proof of concepts. Its ability to require
JavaScript libraries from npm opens up the whole garden. <a href="https://clojurescript.org/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules">ClojureScript
is not an Island</a>.</p>
<h2 id="extras">Extras</h2>
<p>While the <a href="#goals">goals above</a> have been met, there&rsquo;s still a few things that
can make the experience better.</p>
<h3 id="escaping-callback-hell-through-core-dot-async">Escaping callback hell through core.async</h3>
<p>One of the main selling points of ClojureScript are the consistent
syntax of a lisp vs the quirks of JavaScript, and a way out of
callback hell thanks to core.async.</p>
<p>A core.async tutorial is out of the scope of this article, but
we&rsquo;ll see how we can use it to escape callback hell while working
with the AWS SDK.</p>
<p>Full disclosure: replacing a single callback with core.async is not
a good idea. If there&rsquo;s just a few callbacks in your project with
no coordination, then using callbacks is fine. When callbacks need
to be coordinated, that&rsquo;s when core.async starts to shine.</p>
<p>The <code>list-buckets</code> function above can be rewritten with core.async:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">&lt;&lt;&lt;</span> [<span style="color:#b8860b">f</span> <span style="color:#666">&amp;</span> <span style="color:#b8860b">args</span>]
  (<span style="color:#a2f;font-weight:bold">let </span>[<span style="color:#b8860b">c</span> (<span style="color:#00a000">chan</span>)]
    (<span style="color:#a2f">apply </span><span style="color:#b8860b">f</span> (<span style="color:#a2f">concat </span><span style="color:#b8860b">args</span> [<span style="color:#666">#</span>(<span style="color:#00a000">put!</span> <span style="color:#b8860b">c</span> [<span style="color:#b8860b">%1</span> <span style="color:#b8860b">%2</span>])]))
    <span style="color:#b8860b">c</span>))

(<span style="color:#00a000">go</span> (<span style="color:#00a000">pprint</span> (<span style="color:#00a000">&lt;!</span> (<span style="color:#00a000">&lt;&lt;&lt;</span> <span style="color:#666">#</span>(<span style="color:#00a000">.listBuckets</span> <span style="color:#b8860b">s3</span> <span style="color:#b8860b">%</span>)))))
</code></pre></div><p>The <code>&lt;&lt;&lt;</code> function takes a function <code>f</code> and its arguments, and it
applies <code>f</code> to the list of arguments BUT it adds one more argument
to the end: an anonymous function that puts the return values of <code>f</code>
to a channel.</p>
<p>Conveniently, most of the AWS SDK functions use the pattern of
requiring a callback as the last argument that takes two arguments:
<code>error</code> and <code>data</code> to indicate an error or the returned data
respectively.</p>
<p>This allows us to write asynchronous code as if it was a regular
synchronous invocation:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">handler</span>
  <span style="color:#b44">&#34;Lambda main entry point&#34;</span>
  [<span style="color:#b8860b">_</span> <span style="color:#b8860b">_</span> <span style="color:#b8860b">callback</span>]
  (<span style="color:#00a000">go</span>
    (<span style="color:#a2f;font-weight:bold">let </span>[[<span style="color:#b8860b">error</span> <span style="color:#b8860b">buckets</span>] (<span style="color:#00a000">&lt;!</span> (<span style="color:#00a000">&lt;&lt;&lt;</span> <span style="color:#666">#</span>(<span style="color:#00a000">.listBuckets</span> <span style="color:#b8860b">s3</span> <span style="color:#b8860b">%</span>)))]
      (<span style="color:#00a000">callback</span> <span style="color:#b8860b">nil</span>
                (<span style="color:#00a000">clj-&gt;js</span> {<span style="color:#b8860b">:status</span> <span style="color:#666">200</span>
                          <span style="color:#b8860b">:body</span> {<span style="color:#b8860b">:s3-buckets</span> <span style="color:#b8860b">buckets</span>
                                 <span style="color:#b8860b">:error</span> <span style="color:#b8860b">error</span>}
                          <span style="color:#b8860b">:headers</span> {}})))))
</code></pre></div><p>Again, this is a very simple example and the gain is not very
obvious. But when your application starts scaling up and
coordination is required, that&rsquo;s when core.async shines.</p>
<p>Think coordinating three processes: a DynamoDB request, publishing a
message to Kinesis and downloading a file from S3 and doing some
data crunching with it. All three have different running times, and
you need to return your response only when all three are
done. Possible in JavaScript? yes, but not pretty. With core.async
we can have coordination without callbacks.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a2f;font-weight:bold">def </span><span style="color:#b8860b">c</span> (<span style="color:#00a000">chan</span>))

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">simulated-request</span> [<span style="color:#b8860b">c</span> <span style="color:#b8860b">request-type</span>]
  (<span style="color:#00a000">go</span>
    (<span style="color:#a2f;font-weight:bold">let </span>[<span style="color:#b8860b">seconds</span> (<span style="color:#a2f">* </span>(<span style="color:#a2f">rand </span><span style="color:#666">5</span>) <span style="color:#666">1000</span>)
          <span style="color:#b8860b">_</span> (<span style="color:#00a000">&lt;!</span> (<span style="color:#00a000">timeout</span> <span style="color:#b8860b">seconds</span>))]
      (<span style="color:#00a000">&gt;!</span> <span style="color:#b8860b">c</span> {<span style="color:#b8860b">:response</span> <span style="color:#b8860b">request-type</span> <span style="color:#b8860b">:time</span> <span style="color:#b8860b">seconds</span>}))))

(<span style="color:#a2f;font-weight:bold">defn </span><span style="color:#b8860b">process-actions</span> [<span style="color:#b8860b">c</span>]
  (<span style="color:#00a000">go-loop</span> [<span style="color:#b8860b">responses</span> []]
    (<span style="color:#a2f;font-weight:bold">let </span>[{<span style="color:#b8860b">:keys</span> [<span style="color:#b8860b">response</span> <span style="color:#b8860b">time</span>] <span style="color:#b8860b">:as</span> <span style="color:#b8860b">r</span>} (<span style="color:#00a000">&lt;!</span> <span style="color:#b8860b">c</span>)]
      (<span style="color:#a2f">println </span><span style="color:#b44">&#34;I&#39;m done:&#34;</span> <span style="color:#b8860b">response</span> <span style="color:#b44">&#34;. Took&#34;</span> <span style="color:#a2f">time </span><span style="color:#b44">&#34;ms.&#34;</span>)
      (<span style="color:#a2f;font-weight:bold">if </span>(<span style="color:#a2f">= </span>(<span style="color:#a2f">count </span><span style="color:#b8860b">responses</span>) <span style="color:#666">2</span>)
        (<span style="color:#00a000">do</span>
          (<span style="color:#a2f">println </span><span style="color:#b44">&#34;All done! This was the result:&#34;</span>)
          (<span style="color:#00a000">pprint</span> (<span style="color:#a2f">conj </span><span style="color:#b8860b">responses</span> <span style="color:#b8860b">r</span>)))
        (<span style="color:#00a000">recur</span> (<span style="color:#a2f">conj </span><span style="color:#b8860b">responses</span> <span style="color:#b8860b">r</span>))))))

(<span style="color:#00a000">simulated-request</span> <span style="color:#b8860b">c</span> <span style="color:#b8860b">:dynamodb-request</span>)
(<span style="color:#00a000">simulated-request</span> <span style="color:#b8860b">c</span> <span style="color:#b8860b">:kinesis-push</span>)
(<span style="color:#00a000">simulated-request</span> <span style="color:#b8860b">c</span> <span style="color:#b8860b">:s3-download</span>)

(<span style="color:#00a000">process-actions</span> <span style="color:#b8860b">c</span>)
</code></pre></div><p>This coordination without callbacks can be leveraged in your lambda
functions.</p>
<h3 id="packaging-for-smaller-file-size">Packaging for smaller file size</h3>
<p><code>node_modules</code> is notorious for its big size. While a typical
uberjar will very likely be bigger than a comparable ClojureScript
zip file including its npm dependencies, there are actions we can
take to reduce the final package size.</p>
<blockquote>
<p>The lambda cold start time is directly proportional to the
deployment zip archive.</p>
</blockquote>
<ol>
<li>Use production dependencies. Run <code>npm install --production</code> in
your project root.</li>
<li>Use a tool to remove unnecessary files. I&rsquo;ve used <a href="https://github.com/tj/node-prune">node-prune</a> and
it can significantly reduce your <code>node_modules</code> directory size.</li>
<li>Declare development dependencies as such. Run <code>npm install -D name-of-library</code> or edit <code>project.json</code> directly.</li>
</ol>
<p>With the actions above you&rsquo;re realistically looking into a ~30%
reduction in size of the final bundle.</p>
<h3 id="automating-everything-with-make">Automating everything with make</h3>
<p>Leiningen is my tool of choice when working with Clojure(Script)
projects. There are however, other project related tasks that should
fall outside the responsibilities of leiningen. In writing lambda
functions with ClojureScript, tasks such as:</p>
<ul>
<li>Creating the final bundle for deployment.</li>
<li>Pruning the size of the <code>node_modules</code> directory.</li>
<li>Deploying the lambda.</li>
<li>Cleaning up compilation artifacts and npm dependencies.</li>
</ul>
<p>Make is exactly the tool for the job. Zipping up your project and
running <code>aws lambda update-function-code ...</code> by hand gets old real
quick.</p>
<h3 id="leiningen-template">Leiningen template</h3>
<p>I might write a leiningen template similar to <a href="http://github.com/cesarolea/anvil-lein-template">anvil</a> if I end up
writing many ClojureScript lambdas with these same patterns.</p>
<h2 id="credits">Credits</h2>
<ul>
<li><a href="https://dev.to/beders/developing-testing-and-deploying-aws-lambda-functions-written-in-clojurescript-284l">This article in dev.to</a>. I&rsquo;ve had the idea of leveraging
ClojureScript for AWS lambda development for a few years now, but
there was always <em>something</em> that prevented me from proceeding. The
article provided much guidance, but also the reassurance that there
was someone out there that got it to work.</li>
<li><a href="https://purelyfunctional.tv/mini-guide/core-async-code-style/">PurelyFunctional.tv</a> article on core.async guide. I straight up
lifted the <code>&lt;&lt;&lt;</code> function and some ideas from the linked
article. The site is a treasure trove!</li>
</ul>

			</div>

			<div class="tags">
				
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright César Olea 2021 </div>
	</nav>
</div><script>feather.replace()</script>
</body>
</html>
